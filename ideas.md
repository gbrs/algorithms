## Задачи с отрезками

Часто это задачи про расписание.  
Например, найти время, когда все кассы работают.  
Считаем отрезки. Вводим координаты в список с кортежиками: (-1, координата начала) или (1, координата конца). 
Список сортируем. И начинаем в каунтер складывать: cnt -= lst[0]. Если в т.7 один отрезок заканчивается, 
а другой начинается, то получится что в этой точке 2 отрезка. Если задача будет какой-то другой, то первые числа
в кортеже можно другие поставить.


## Дерево отрезков
http://e-maxx.ru/algo/segment_tree
Например, дан массив чисел и надо для них находить минимум: стопицот запросов типа - минимум с 12 по 37-й элемент.
Строим дерево "от этого массива": сперва минимумы для пар соседних элементов, потом слой с минимумами пар пар 
(т.е. для четверок элементов). И так до общего минимума.  
Надо создать несколько функций. Для создания дерева (build), для добавления в массив новых элементов (update; 
если такое поведение в задаче есть), для извлечения ответа (get; например, ответ на отрезке l-r).
Дерево храним в массиве. Если длина исходного массива - 2^k, то длина массива дерева - 2^(k+1). Но если такая длина 
не гарантируется, то с запасом можно выделить 4*n ячеек. Корень дерева - ячейка 1 (нулевая ячейка не задействуется). 
Адреса детей ячейки m - 2*m и 2*m+1, родителя - m // 2.  
Функция build. Строим дерево рекурсивно. Начинаем с вершинки, потом идем в ее детей (2*m и 2*m+1, при этом диапазон, 
за который отвечает узел, располовинивается) и т.д. Когда доходим до листа (диапазон становится в 1 элемент), 
ставим значение из исходных данных. На обратном ходе рекурсии вычисляем значения в узлах.  
Функция get. Ответ ищем рекурсивно. Узел отвечает за элементы исходного массива [L, R]. Если [l, r] и [L, R] 
не пересекаются, то возвращаем плюс бесконечность (для задачи поиска минимума). [L, R] внутри [l, r] - значение из узла. 
Во всех остальных случаях делим отрезок пополам и вызываем рекурсивно функцию для этих подотрезков. 
Из возвращенных чисел делается ответ на обратном ходу рекурсии.  
Функция update. Движемся рекурсивно по узлам в сторону листа изменения значения. На обратном ходе пересчитываем 
значения в родительских узлах. 


## Графы

Обычно, задачи на графы формально вообще не про графы: надо еще догадаться, что здесь узлы, а что ребра. 

### Алгоритм Дейкстры
Граф без отрицательных ребер. Найти минимальные расстояния до всех вершин.  
Инициализируем массив расстояний бесконечностями. Расстояние от самой вершины до неё же - 0. 
Все вершины графа помечаются как непосещённые.  
Шаг алгоритма:
- Если все вершины посещены, алгоритм завершается.
- В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальное расстояние 
(на первом шаге это стартовая вершина).
- Мы рассматриваем все возможные маршруты, в которых u является предпоследним пунктом. 
Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, 
кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, 
соединяющего u с этим соседом. Если полученное значение длины меньше значения метки соседа, заменим значение метки 
полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

Используем очередь.

### Алгоритм Форда-Беллмана
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Найти минимальные расстояния до всех вершин.  
Инициализируем массив расстояний бесконечностями. Расстояние от самой вершины до неё же - 0.  
Пробегаемся по всем ребрам. Если расстояние до стартовой вершины бесконечность, ничего не делаем. Если нет, 
то обновляем расстояние, если путь по данному ребру оказывается короче того, который уже записан для конечной вершины. 
dist[b] = min(dist[b], dist[a] + weight).  
Так делаем V - 1 раз: крайний случай, когда все вершинки расположены в одну линейную цепочку. 
На каждом шаге i гарантировано находим кратчайшее расстояние до вершин ранга i.  
Очень простой алгоритм: цикл в цикле - до V - 1 и обход по всем ребрам.  
В большинстве случаев V - 1 прогонов - слишком много, большАя/бОльшая часть - в пустую.  
Можно завести флаг, чтобы брекнуться, если на предыдущей итерации цикла не было произведено ни одного изменения.  
А можно на первом шаге обновить расстояние только для соседей стартовой вершины. А на последующих шагах пытаться 
обновлять только соседей вершин, которые были обновлены на предыдущем шаге. Очередь нам в помощь. Это называют SPFA /
 алгоритм Мура / алгоритм Ф-Б с очередью.


![Методы определения расстояний между всеми вершинами](images/all_distances_table.png)

### Алгоритм Флойда-Уоршелла
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Построить матрицу минимальных расстояний между 
всеми вершинами.  
Динамическое программирование.  
Строим матрицу смежности d-1[i, j]. Если путей между двумя вершинами несколько, записываем кратчайшее расстояние. 
На главной диагонали - нули. Если есть отрицательные петли, то на главную диагональ записываем их 
(или минус бесконечность?). 
Если пути нет, записываем бесконечность.  
Теперь будем сравнивать имеющиеся пути с путем из i в 0, а потом из 0 в j. Где нашли путь короче, там заменяем, 
получая матрицу d0[i, j]. Далее повторяем с промежуточной вершиной 1 - получаем кратчайший путь из тех, которые идут 
прямо из i в j или через вершины 0 и 1. И т.д.  
Получается простейший алгоритм с тремя вложенными циклами: во внешнем перебираем промежуточные вершины, 
во внутренних - i и j.

### Алгоритм Джонсона
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Построить матрицу минимальных расстояний между 
всеми вершинами.  
Какой-то кентаврик.  
Запускается алгоритм Форда-Беллмана из всех вершин графа одновременно. Изменяем вес ребер по результатам ФБ, 
они становятся неотрицательными, кратчайшие пути (но не их значения) не изменяются. Теперь можно запускать Дейкстру из 
всех вершин. Корректируем расстояния, используя результаты ФБ.

### Топологическая сортировка
DAG - ориентированный ацикличный(!) граф.  
DFS делаем и на выходе из узла (лист или обошли всех детей уже) добавляем узел в массив. Потом, перевернув этот массив, 
получаем "отсортированный" список узлов: для любой вершины из него знаем, что путь в нее шел только через вершины, 
расположенные левее нее. Все ребра в этом списке идут строго слева направо. Топологическая сортировка не единственна, 
это не помешает.  
Задача нахождения кратчайшего пути во взвешенном графе решается тогда за O(V + E). Создаем "обратный" список смежности 
(осс): откуда в эту вершину можем прийти. Внешний цикл - по вершинам топологически отсортированного, внутренний - 
по предкам выбранной во внешнем цикле вершины (используем осс). dist[i] = min(dist[i], dist[j] + длина i-j). 
В Форде-Беллмане мы наугад тыкали все пути, а здесь, благодаря осс и топсорту, мы только то, что надо перебираем.  
Задача на нахождение количества путей до какой-то вершинки. Тот же алгоритм. cnt[i] = сумма всех cnt[j] (количеств 
путей до родителей).  
Нахождение компонент сильной связности (ксс) в ориентированном графе с циклами. Внутри ксс можно в конце концов попасть 
из каждого узла в каждый. Узлов в ксс может быть 1, 3 и более. Делаем топсорт (конечно, неправильно так говорить, 
когда граф с циклами: сортировка по убыванию времени выхода при dfs). Создаем граф, в котором все ребра направлены в 
противоположном направлении и начинаем пытаться обход. Теперь из любого узла будет достижима только своя компонента 
связности. Бежим по топсорту и dfsом находим всю ксс для первого узла, отмечаем эти вершины, как принадлежащие первой 
ксс, отмечаем уже посещенные вершины. Теперь строим ксс для следующей в топсорте вершины, которую мы еще не посетили.  
Бывают задачи, в которых надо считать не с начала списка топсорта, а с конца.  




### HyperLogLog
Задача: посчитать количество уникальных элементов.
Человек бросает монетку и записывает самую длинную серию орлов. Если у него записано 3, вряд ли он бросал много раз, 
а если 20, то, скорее всего, он бросал много раз.
Берем значение, вычисляем хеш, считаем максимальное количество нулей подряд во всех хешах, делаем оценку количества 
уникальных значений.  
Чтобы случайность меньше влияла, по последним битам можем распределить по отдельным потокам и по каждому из них 
отдельный подсчет вести. Количество таких бит (т.е. количество потоков) определяет точность алгоритма. Все одинаковые 
элементы будут попадать в одну корзину.  
Далее вычисляют среднее гармоническое (с неким нормировочным коэффициентом?).  
Это, конечно, упрощенное описание реально используемых алгоритмов.  
Алгоритм можно использовать для данных, расположенных на разных серверах.  
Google Analytics 4 не считает показатели точно, а дает оценку таким алгоритмом.
