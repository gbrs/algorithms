## Задачи с отрезками

Часто это задачи про расписание.  
Например, найти время, когда все кассы работают.  
Считаем отрезки. Вводим координаты в список с кортежиками: (-1, координата начала) или (1, координата конца). 
Список сортируем. И начинаем в каунтер складывать: cnt -= lst[0]. Если в т.7 один отрезок заканчивается, 
а другой начинается, то получится что в этой точке 2 отрезка. Если задача будет какой-то другой, то первые числа
в кортеже можно другие поставить.


## Графы

Обычно, задачи на графы формально вообще не про графы: надо еще догадаться, что здесь узлы, а что ребра. 

### Алгоритм Дейкстры
Граф без отрицательных ребер. Найти минимальные расстояния до всех вершин.  
Инициализируем массив расстояний бесконечностями. Расстояние от самой вершины до неё же - 0. 
Все вершины графа помечаются как непосещённые.  
Шаг алгоритма:
- Если все вершины посещены, алгоритм завершается.
- В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальное расстояние 
(на первом шаге это стартовая вершина).
- Мы рассматриваем все возможные маршруты, в которых u является предпоследним пунктом. 
Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, 
кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, 
соединяющего u с этим соседом. Если полученное значение длины меньше значения метки соседа, заменим значение метки 
полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

Используем очередь.

### Алгоритм Форда-Беллмана
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Найти минимальные расстояния до всех вершин.  
Инициализируем массив расстояний бесконечностями. Расстояние от самой вершины до неё же - 0.  
Пробегаемся по всем ребрам. Если расстояние до стартовой вершины бесконечность, ничего не делаем. Если нет, 
то обновляем расстояние, если путь по данному ребру оказывается короче того, который уже записан для конечной вершины. 
dist[b] = min(dist[b], dist[a] + weight).  
Так делаем V - 1 раз: крайний случай, когда все вершинки расположены в одну линейную цепочку. 
На каждом шаге i гарантировано находим кратчайшее расстояние до вершин ранга i.  
Очень простой алгоритм: цикл в цикле - до V - 1 и обход по всем ребрам.  
В большинстве случаев V - 1 прогонов - слишком много, большАя/бОльшая часть - в пустую.  
Можно завести флаг, чтобы брекнуться, если на предыдущей итерации цикла не было произведено ни одного изменения.  
А можно на первом шаге обновить расстояние только для соседей стартовой вершины. А на последующих шагах пытаться 
обновлять только соседей вершин, которые были обновлены на предыдущем шаге. Очередь нам в помощь. Это называют SPFA /
 алгоритм Мура / алгоритм Ф-Б с очередью.


![Методы определения расстояний между всеми вершинами](images/all_distances_table.png)

### Алгоритм Флойда-Уоршелла
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Построить матрицу минимальных расстояний между 
всеми вершинами.  
Динамическое программирование.  
Строим матрицу смежности d-1[i, j]. Если путей между двумя вершинами несколько, записываем кратчайшее расстояние. 
На главной диагонали - нули. Если есть отрицательные петли, то на главную диагональ записываем их 
(или минус бесконечность?). 
Если пути нет, записываем бесконечность.  
Теперь будем сравнивать имеющиеся пути с путем из i в 0, а потом из 0 в j. Где нашли путь короче, там заменяем, 
получая матрицу d0[i, j]. Далее повторяем с промежуточной вершиной 1 - получаем кратчайший путь из тех, которые идут 
прямо из i в j или через вершины 0 и 1. И т.д.  
Получается простейший алгоритм с тремя вложенными циклами: во внешнем перебираем промежуточные вершины, 
во внутренних - i и j.

### Алгоритм Джонсона
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Построить матрицу минимальных расстояний между 
всеми вершинами.  
Какой-то кентаврик.  
Запускается алгоритм Форда-Беллмана из всех вершин графа одновременно. Изменяем вес ребер по результатам ФБ, 
они становятся неотрицательными, кратчайшие пути (но не их значения) не изменяются. Теперь можно запускать Дейкстру из 
всех вершин. Корректируем расстояния, используя результаты ФБ.





### HyperLogLog
Задача: посчитать количество уникальных элементов.
Человек бросает монетку и записывает самую длинную серию орлов. Если у него записано 3, вряд ли он бросал много раз, 
а если 20, то, скорее всего, он бросал много раз.
Берем значение, вычисляем хеш, считаем максимальное количество нулей подряд во всех хешах, делаем оценку количества 
уникальных значений.  
Чтобы случайность меньше влияла, по последним битам можем распределить по отдельным потокам и по каждому из них 
отдельный подсчет вести. Количество таких бит (т.е. количество потоков) определяет точность алгоритма. Все одинаковые 
элементы будут попадать в одну корзину.  
Далее вычисляют среднее гармоническое (с неким нормировочным коэффициентом?).  
Это, конечно, упрощенное описание реально используемых алгоритмов.  
Алгоритм можно использовать для данных, расположенных на разных серверах.  
Google Analytics 4 не считает показатели точно, а дает оценку таким алгоритмом.
