# Математика

Часто в олимпиадных задачах требуется посчитать какие-то большие комбинаторные величины по простому модулю 
(чаще всего 10^9 + 7). 
\Это делают для того, чтобы участникам не приходилось использовать длинную арифметику, 
и они могли сосредоточиться на самой задаче.  
Почему 10^9 + 7 (иногда +9)? Большое. Простое. *2 помещается в int. ^2 помещается long long. Легко вбить: 1e9+7.  
Еще иногда используют 998244353. Удобно в каком-то варианте быстрого преобразования Фурье. 
Но иногда добавляют его, просто, чтобы сбить с панталыку.


## Быстрое возведение в степень
Если степень pow нечетная тупо умножаем очередной раз на число. 
Если четная, то возводим result в квадрат, а степень уполовиниваем:  
```python
while pow > 0:
    if pow mod 2 == 1
        result *= value
    value *= value
    pow /= 2;
```  


## Решето Эратосфена
Заполняем массив трушками. 0 и 1 - фолсы. 
Бежим и заменяем фолсами все элементы кратные 2, кроме самой 2. 
Потом берем следующий не фолс элемент: это будет 3 и фолсами заменяем все элементы кратные 3. 
И т.д.  
```C
vector<bool> sieve(int n) {
    vector<bool> is_prime(n+1, true);
    for (int i = 2; i <= n; i++)
        if (is_prime[i])
            for (int j = 2*i; j <= n; j += i)  -- до 2*i мы уже обработали все, шаг - i
                prime[j] = false;
    return is_prime;            
}
```  
Сложность - O(N*loglogN)


## Обратный элемент по модулю
Не понятно, как находить остаток от деления по модулю частного: (a / b) % m.  
Можем перейти так: (a / b) % m = (a * b^-1) % m, где b^-1 находится из условия: b * b^-1 = 1 (mod m).  
Малая теорема Ферма для простого m: b^(m - 1) = 1 (mod m). Делим обе стороны на b: b^(m - 2) = b^-1 (mod m). 
То есть нам надо быстрым возведением в степень найти b^(m - 2). 
Но работает только для простого m! Для составного тоже есть свои подходы.  


## Алгоритм Евклида
Наибольший общий делитель gcd:
```C
int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}
```  
Конечно, в C++ есть встроенный gcd.  


## Наименьшее общее кратное
a * b = НОК(a, b) * НОД(a, b)


## Диофантовы уравнения

[описание метода решения](https://ru.wikihow.com/решить-линейное-диофантово-уравнение)  
[ и его реализация в рекурсивном алгоритме](https://ru.algorithmica.org/cs/modular/extended-euclid/)


