## Система непересекающихся множеств (СНМ)
https://ru.algorithmica.org/cs/set-structures/dsu/  
Умеет отвечать на вопросы типа «находятся ли элементы a и b в одном множестве» и «чему равен размер данного множества». 
Часто используется в графовых алгоритмах для хранения информации о связности компонент.  
Структура должна поддерживать 2 операции:
- Объединить два каких-либо множества;
- Запросить, в каком множестве сейчас находится указанный элемент.  

Изначально у нас n элементов, каждый в своём множестве. 
В каждом множестве должен быть один "лидер". 
По его номеру мы и "называем" множество. 
Создаем массив лидеров: кто является лидером данного элемента. Заполняем его напротив индексов от 1 до n - 1 числами 
от 1 до n - 1 поскольку сейчас каждый элемент сам себе лидер.  
Множества элементов мы будем хранить в виде деревьев, пристегивая при объединении лидера одного множества к лидеру 
другого. 
Но тут надо будет оптимизировать, чтобы деревья не становились слишком глубокими, бамбукообразными.  
Для запроса в каком множестве находится какой-то элемент нужно только подняться по ссылкам до корня.  
Теперь оптимизации.  
Эвристика сжатия пути. При каждом запросе (и второго, и первого) типа все вершины, попавшиеся на пути, 
запоминаем и потом подсоединяем их напрямую к лидеру. 
Простой код, если написать рекурсивно (после рекурсивного вызова переподсоединение делать), 
но можно и список пройденных вершин копить и потом вершины из него переподсоединить к лидеру. 
Чем больше запросов второго типа обработано, тем быстрее будут обрабатываться последующие.  
Ранговая эвристика. Менее глубокое дерево подвешиваем к более глубокому - максимальная глубина не вырастет. 
Надо вести массив рангов лидеров.  
Весовая эвристика. Меньшее по количеству элементов дерево подвешиваем к большему. Надо вести массив весов для лидеров. 
Часто в задачах про графы надо отвечать на вопросы про размер компонент связности и тогда такая эвристика удобна.  
При использовании одной из эвристик сложность будет O(log n). 
Но при использовании эвристики сжатия плюс весовой или ранговой, асимптотика будет уже O(a(n)), 
где a(n) — обратная функция Аккермана (для всех адекватных для олимпиад чисел не превосходящая 4).

## Дерево отрезков
http://e-maxx.ru/algo/segment_tree  
«ДО снизу». Можно делать все операции итеративно — так получится раз в 7 быстрее, 
но писать что-либо нетривиальное (например, массовые операции) так будет намного труднее.  
Например, дан массив чисел и надо для них находить минимум: 
стопицот запросов типа - минимум с 12 по 37-й элемент [l, r].
Строим дерево "от этого массива": сперва минимумы для пар соседних элементов, 
потом слой с минимумами пар пар (т.е. для четверок элементов). 
Потом для восьмерок. И так до общего минимума.  
Надо создать несколько функций: 
- для создания дерева (build); 
- для добавления в массив новых элементов (update; если такое поведение в задаче есть); 
- для извлечения ответа (get; например, ответ на отрезке l-r).  

Все функции рекурсивные.  
Дерево храним в массиве. Если длина исходного массива - 2^k, то длина массива дерева - 2^(k+1). 
Но если такая длина не гарантируется, то с запасом можно выделить 4n ячеек. 
Пусть корень дерева - ячейка 1 (нулевая ячейка не задействуется). 
Адреса детей ячейки m - это 2m и 2m+1, родителя - m // 2.  
_Функция build_. Строим дерево рекурсивно. Начинаем с вершинки, потом идем в ее детей (2*m и 2*m+1, при этом диапазон, 
за который отвечает узел, располовинивается) и т.д. Когда доходим до листа (диапазон становится в 1 элемент), 
ставим значение из исходных данных. На обратном ходе рекурсии вычисляем значения в узлах.  
_Функция get_. Ответ ищем рекурсивно. Узел отвечает за элементы исходного массива [L, R]. Если [l, r] и [L, R] 
не пересекаются, то возвращаем плюс бесконечность (для задачи поиска минимума). [L, R] внутри [l, r] - значение из узла. 
Во всех остальных случаях делим отрезок пополам и вызываем рекурсивно функцию для этих подотрезков. 
Из возвращенных чисел делается ответ на обратном ходу рекурсии.  
_Функция update_. Движемся рекурсивно по узлам в сторону листа изменения значения. На обратном ходе пересчитываем 
значения в родительских узлах.  
Технически легче писать полуинтервалами, а не отрезками: не надо будет в индексах где-то +-1 добавлять. 
mid = (l + r) / 2; [l, mid) и [mid, r)


### Дерево отрезков с операцией на отрезке
Дан массив чисел. Тысячи операций двух типов:
- добавить одно и то же число ко всем элементам от a до b;
- вывести текущее значение k-го числа.

Легко решается разностным массивом: первая операция за O(1), вторая - за O(n).  
Дерево отрезков, построенное на разностном массиве делает первую операцию за log(n), но и вторую то же за log(n).  
В дереве поддерживаем сумму элементов. При запросе второго типа выводим сумму с 1 по k.


### Несогласованные поддеревья и массовое обновление
lazy propagation - ленивое распространение. Очень важно научиться его писать — она часто встречается на олимпиадах.  
Идея «давайте будем всё делать в последний момент» применима не только в ДО, 
но и в других структурах ~~и в реальной жизни~~.  
Задача присвоения значения не отрезке и расчета суммы на отрезке. 
При запросе присваивания на отрезке будем помечать некоторые вершины, 
что они и все их дети «покрашены» в какое-то число - имеют несогласованную модификацию. 
Непосредственно спускаться до листьев без необходимости мы не будем. 
Несогласованности будем хранить в отдельном массиве с тем же размером, что и дерево.  
Когда нам позже понадобятся правильные значения таких вершин и их детей, 
мы будем делать «проталкивание» несогласованности из текущей вершины в её сыновей: 
если несогласованность есть, пересчитаем сумму текущего отрезка и передадим несогласованность сыновьям, 
а несогласованность материнской ячейки занулим. 
Теперь материнская вершина согласована, а ее сыновья - нет. 
Мы протолкнули несогласованность/модификацию. 
Когда нам потом понадобятся их сыновья, мы будем делать то же самое.  
При реализации создадим вспомогательную функцию push, 
которая будет производить проталкивание информации из этой вершины в обоих её сыновей. 
Вызывать её стоит перед каждым спуском в сыновей.  
В другом варианте кода, сумму в узле пересчитывали сразу как несогласованность для этого узла изменяли. 
Важно пропушить при переходе в детей, когда считать сумму в узле не важно?  
Какие функции кроме sum можно так обрабатывать? Те, которые обладают коммутативностью ( f(x, y) = f(y, x) ) ?  
При поиске максимума и замене на k всех чисел на отрезке, которые меньше k, нам даже не обязательно проталкивать. 
Инициализируем все вершинки дерева -inf 
и потом записываем в них максимальные значения, выбирая между k и тем, что уже хранится в вершинке. 
При get(k) идем от вершины k вверх по родителям и ищем максимальное число.  



