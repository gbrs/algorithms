Список плейлистов, которые надо просмотреть/законспектировать:   
Двоичное дерево поиска https://www.youtube.com/watch?v=8Gdp7XJeW5g&list=PLGhUJWLZ8uQ5Ewplzb1ER29p4-kQme5Yr

Перенести краткие описания алгоритмов для деревьев  
Описания алгоритмов: матрица


### Два указателя
Классические варианты: 
- Оба указателя движутся по массиву в одну сторону (без возвратов). Скользящее окно;
- Указатели с разных краев массива движутся навстречу друг другу;
- Указатели движутся по двум массивам "параллельно".


### Сканирующая прямая
Задачи с отрезками. Часто это задачи про расписание.  
Например, найти время, когда все кассы работают.  
Вводим координаты в список с кортежиками: (координата начала, -1) или (координата конца, 1). 
Список сортируем. Считаем отрезки - начинаем в каунтер складывать: cnt -= tpl[0]. Если в т.7 один отрезок заканчивается, 
а другой начинается, то получится что в этой точке 2 отрезка. Если задача будет какой-то другой, то первые числа
в кортеже можно другие поставить.


## Жадные алгоритмы
Обычно это о какой-то сортировке элементов (возможно какой-то хитрой с компаратором), 
а потом нужно жадно выбирать элементы.

### Жадный слушатель
В нескольких залах весь день идут лекции разной длительности. Как посетить наибольшее количество лекций?  
Сортировать надо по времени окончания лекций! А дальше жадно выбирать ближайшую лекцию.


### Полиномиальное хеширование
https://www.youtube.com/watch?v=bH45DuZjBWw https://ru.algorithmica.org/cs/hashing/polynomial/  
Например, задача найти вхождение заданной строки s' в некоторую другую строку s. Длины строк -  m и n.  
Наивный подход - сравниваем элементы, начиная с первого элемента строки s, потом начиная со второго... O(n * m).  
Давайте сравнивать не поэлементно, а хеши сравниваемых строк. Но вычисление хеша тоже будет O(m). 
Постараемся сделать вычисление быстрее для s.  
Алгоритм Рабина-Карпа.  
Прямой полиномиальный хеш: h = (s0 * k^0 + s1 * k^1 + s2 * k^2 + ... + sm-1 * k^(m-1)) % p  
Обратный полиномиальный хеш: h = (s0 * k^(m-1) + s1 * k^(m-2) + s2 * k^(m-3) + ... + sm-1 * k^0) % p  
Лучше считать их в цикле так (для обратного, например): ((s0 * k + s1) * k + s2) * k + ... 
Только в коде не забывать % p.  
k должен быть больше размера алфавита, p - большое число (чтобы не было коллизий). 
Вроде, есть мнение, что они должны быть взаимно простыми. 
Чтобы деление по модулю можно было делать? 
Можно взять k простое, тогда p проще подобрать взаимно простым.  
Посчитаем хеш h0 первой подстроки строки s (от 0 до m-1). Следующий хеш не будем считать "с нуля", а пересчитаем 
(для обратного): h1 = (h0 * k - s0 * k^m + sm) % p. 
(Для прямого хеша 'нельзя' построить h1? h1 = (h0 - s0) / k + sm * k^m. Но для операции деления не сохраняется 
остаток по делению). 
И тогда в среднем сложность вычисления хешей станет O(1), а всего алгоритма O(m + n), видимо.  
Если хеши совпали, то надо перепроверить поэлементно?  
Так же по несложным формулам можно пересчитывать хеши при удалении префикса, суффикса, конкатенации строк. 
Предпосчитав хеши всех возможных префиксов (один левый элемент, два левых, три левых...), можно вычислять 
хеш любого подотрезка h(s[l:r]) = (hr - hl) / k^l.  

### Алгоритм Кнута-Морриса-Пратта
https://www.youtube.com/watch?v=S2I0covkyMc  
КМП. Общие идеи только. Как я понял. Чтобы в будущем разобраться.  
Задача найти вхождение заданной строки s' в некоторую другую строку s. Длины строк - m и n.  
Наивный подход - сравниваем элементы, начиная с первого элемента строки s, потом начиная со второго... O(n * m).  
Почему надо смещаться на 1 элемент, а не на m? Потому что внутри s' могут быть элементы, которые похожи на начало s'. 
Поэтому смещаться надо на величину, учитывающую такие повторы.  
Создаем префикс-функцию - массив, в котором на i-ой позиции максимально возможная длина совпадающих префиксов и 
суффиксов на отрезке s'[0:i].
(Собственных префиксов/суффиксов. То есть не учитываются п и с длиной во всю рассматриваемую строку). 
Кстати, префикс и суффикс могут пересекаться. 
Например, префикс-функция для 'aataataa':  
'a--a--t--a--a--t--a--a'  
[0, 1, 0, 1, 2, 3, 4, 5].  
Например, для aat нет совпадающих суффиксов и префиксов. Для строки длиной 8, совпадающие префикс и суффикс - 'aataa'.  
Построить префикс-функцию можно наивно за m^3. КМП придумали как это сделать за O(m). Не разобрался в механизме.  
Использование пф для решения задачи описывают по разному.  
Вариант 1. Считаем пф для s' и потом смещаем образец относительно s сразу же не на одну букву, а на столько букв, 
на сколько это позволительно (узнаем это как-то из пф). 
Конечно, в алгоритме нет никаких смещений текстов: ползают два указателя - на s и s'.  
Вариант 2. Конкатенируем s' + какой-то знак отсутствующий в обеих строках + s. Запускаем расчет префикс-функции 
для этой суперстроки. Там где в пф будет стоять значение m заканчивается вхождение s' в эту суперстроку:  
choose#choose life. choose a job.  
000000012345600000001234560000000  
*Алгоритм построения префикс-функции*.  
Я так понял, что основная заслуга КМП как раз в нахождении способа посчитать пф за O(m).  
 |j      |i  
 л и и л л и и л  
Префикс-функция - массив p. p[0] = 0. Изначально j = 0, i = 1.  
Указатель j соответствует длине рассматриваемого в данный момент префикса, указывает на текущий рассматриваемый элемент 
префикса. 
Ползает туда-сюда.  
Указатель i указывает на текущий рассматриваемый элемент суффикса и рассчитываемый элемент префикс-функции. 
Мы его если смещаем, то только на шаг вправо.  
- Тестируем образец длины j, сравнивая s[j] и s[i]. 
  - Если они совпадают — то p[i] = j+1 (нумерация же с нуля) и переходим к следующим индексам i++, j++.  
  - Если же символы отличаются, то уменьшаем длину j: j = p[j-1].
    (Объяснение этого шага, видимо, такое же как в Алгоритме поиска вхождений). 
    Повторяем этот шаг алгоритма с начала. 
- Если так мы доходим до длины j=0 и так и не нашли совпадения, то останавливаем процесс перебора образцов 
  и полагаем p[i] = 0. Переходим к следующему индексу i++ и далее к попыткам нарастить префикс и суффикс "с нуля".  

*Алгоритм поиска вхождений* (вариант 1).  
i          |  
 л и л и л о с ь   л и л и л а с ь  
j          |  
 л и л и л а  
пф:  
 0 0 1 2 3 0  
Указатель i ползет по s, а j - по s'.  
Пока под ними одинаковые буквы смещаем оба указателя вправо на шаг.  
При j=5 - разные буквы. 
Смотрим значение пф[4]. Там число 3. 3 элемента левее ('лил') нынешнего положения указателя j такие же, 
как 3 элемента в начале строки s'. 
Смещаем указатель j на индекс 3. 3 элемента левее него всё те же: 'лил'. 
Это как смещение s' относительно s так, чтобы 'лил' из s' расположился под 'лил' из s.  
Снова сравниваем буквы под указателями i и j. 
И далее по циклу.  
Если буква под i не совпадает с первым символом s', то смещаем i на шаг вправо.  
Нашли, если j == m.  
Удивительно, что обеих частях алгоритма, хотя j ползает туда-сюда, сложность O(n+m).


### HyperLogLog
Задача: посчитать количество уникальных элементов.
Человек бросает монетку и записывает самую длинную серию орлов. Если у него записано 3, вряд ли он бросал много раз, 
а если 20, то, скорее всего, он бросал много раз.  
Берем значения, вычисляем хеши, считаем максимальное количество нулей подряд встретившееся во всех хешах, 
делаем оценку количества уникальных значений.  
Чтобы случайность меньше влияла, по последним битам можем распределить по отдельным потокам и по каждому из них 
отдельный подсчет вести. Количество таких бит (т.е. количество потоков) определяет точность алгоритма. Все одинаковые 
элементы будут попадать в одну корзину.  
Далее вычисляют среднее гармоническое (с неким нормировочным коэффициентом?).  
Это, конечно, упрощенное описание реально используемых алгоритмов.  
Алгоритм можно использовать для данных, расположенных на разных серверах.  
Google Analytics 4 не считает показатели точно, а дает оценку таким алгоритмом.


