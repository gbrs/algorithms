Список плейлистов, которые надо просмотреть/законспектировать:   
Двоичное дерево поиска https://www.youtube.com/watch?v=8Gdp7XJeW5g&list=PLGhUJWLZ8uQ5Ewplzb1ER29p4-kQme5Yr

Перенести краткие описания алгоритмов для деревьев  
Описания алгоритмов: матрица


## Два указателя
Классические варианты: 
- Оба указателя движутся по массиву в одну сторону (без возвратов). Скользящее окно;
- Указатели с разных краев массива движутся навстречу друг другу;
- Указатели движутся по двум массивам "параллельно".


## Сканирующая прямая
Часто используется для решения задач на структуры данных, когда все запросы известны заранее, 
а также в геометрии для нахождения объединений фигур.  
Например, задачи с отрезками (часто это задачи про расписание); найти время, когда все кассы работают; 
точка, покрытая наибольшим количеством отрезков; длина объединения отрезков; скольким отрезкам принадлежит точка. 
Двумерные: площадь объединения прямоугольников.  
Есть события - пары: где произошло (например, координата, время), тип события (например, начало и конец отрезка). 
В зависимости от условия важно в каком порядке рассматривать события разных типов в одной точке. 
Для этого либо делаем кастомный компаратор либо названия событиям правильно задаем, чтобы они после сортировки 
в правильном порядке были обработаны.  
Например, вводим координаты в список с кортежиками: (координата начала, -1) или (координата конца, 1). 
Список сортируем. Считаем отрезки - начинаем в каунтер складывать: cnt -= tpl[0]. 
Если в т.7 один отрезок заканчивается, а другой начинается, то получится что в этой точке 2 отрезка. 

Дана куча отрезков. Со сколькими отрезками пересекается каждый отрезок? N - 1 - количество отрезков, 
с которыми отрезок не пересекается. Значит бежим и все время считаем сколько отрезков уже закончилось 
и сколько еще не началось.



## Жадные алгоритмы
Обычно это о какой-то сортировке элементов (возможно какой-то хитрой с компаратором), 
а потом нужно жадно выбирать элементы.

### Жадный слушатель
В нескольких залах весь день идут лекции разной длительности. Как посетить наибольшее количество лекций?  
Сортировать надо по времени окончания лекций! А дальше жадно выбирать ближайшую лекцию.


## HyperLogLog
Задача: посчитать количество уникальных элементов.
Человек бросает монетку и записывает самую длинную серию орлов. Если у него записано 3, вряд ли он бросал много раз, 
а если 20, то, скорее всего, он бросал много раз.  
Берем значения, вычисляем хеши, считаем максимальное количество нулей подряд встретившееся во всех хешах, 
делаем оценку количества уникальных значений.  
Чтобы случайность меньше влияла, по последним битам можем распределить по отдельным потокам и по каждому из них 
отдельный подсчет вести. Количество таких бит (т.е. количество потоков) определяет точность алгоритма. Все одинаковые 
элементы будут попадать в одну корзину.  
Далее вычисляют среднее гармоническое (с неким нормировочным коэффициентом?).  
Это, конечно, упрощенное описание реально используемых алгоритмов.  
Алгоритм можно использовать для данных, расположенных на разных серверах.  
Google Analytics 4 не считает показатели точно, а дает оценку таким алгоритмом.


## Битовое представление числа
Отрицательное число -x считается так: -x = ~x + 1. 
Тогда у всех отрицательных чисел старший бит - 1. 
-1 - все единички, и после пойдет число 0 со всеми нулями. 

Побитовые операции работают за один такт: &, |, ~, ^.  

Сдвиги работают за один такт:
2^42 можно получить как: 1 << 42  
log_2 n: while ((1 << lgr) <= n)  ++lgr
Получить число, состоящее из k единиц в конце: (1 << k) - 1  
Добавить i-й элемент в множество: x |= (1 << i)  
Удалить i-й элемент из множества: x &= ~(1 << i)
Удалить i-й элемент из множества, если он есть или добавить, если его нет: x ^= (1 << i)

Двоичное число может быть маской - i-й элемент какого-то множества берем, если в маске на этом месте единица. 
Работают с этими масками побитовыми операциями.  
Выделить i-ый бит числа (принадлежит ли i-й элемент множеству):
- (x >> i) & 1 - выдаст то, что надо;
- x & (1 << i) - выдаст либо 0, лбо 2^i

### Гамильтонов путь
Гамильтоновым путь проходит через каждую вершину графа ровно один раз.  
https://ru.wikipedia.org/wiki/Задача_о_гамильтоновом_пути  
https://neerc.ifmo.ru/wiki/index.php?title=Гамильтоновы_графы  
https://foxford.ru/wiki/informatika/postroenie-gamiltonova-tsikla?utm_referrer=https%3A%2F%2Fyandex.ru%2F  

### Перебор подмасок
http://www.e-maxx-ru.1gb.ru/algo/all_submasks  
https://silvertests.ru/GuideView.aspx?id=32340  

### Число подпалиндромов
https://ru.algorithmica.org/cs/general-dynamic/segments/  
https://dxdy.ru/topic106121.html  

## Разное

Чтобы понять рекурсию, надо сначала понять рекурсию.

Вместо for (int i = 0; i < sqrt(n); i++) надо писать for (int i = 0; i * i < n; i++). 
И посмотреть не возможно ли переполнение и тогда перейти на long long.  

(a - b) % m. Есть риск, что скобка отрицательная и в яп C и остаток станет отрицательным. 
Поэтому всегда такой результат еще обрабатываем: ((a - b) % m + m) % m или (a - b + m) % m.  

int a, b, c, m;
c = (a * b) % m. Но вдруг переполнение intа произойдет? Лучше написать c = (long long) a * b % m.

Если память позволяет, то для оптимизации скорости лучше использовать не вектор bool, а вектор char — 
но он займёт в 8 раз больше места. Компьютер не умеет напрямую оперировать с битами, и поэтому 
при индексации к vector<bool> он сначала достаёт нужный байт, а затем битовыми операциями получает нужное значение, 
что занимает приличное количество времени.  


