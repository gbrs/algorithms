# Динамическое программирование 2D

https://www.youtube.com/watch?v=e67Tba6tC1Y  
https://algorithmica.org/tg/knapsack-gis-gcs

В dp хранятся возможные "состояния нашей системы". И, конечно, оно может описываться не только 2 параметрами: 
2d - не предел. И четырехмерные dp - вполне норм. 
Часто в процессе решения вводим слишком много измерений, а потом уже надо стараться выкинуть лишние.  

Восстановление пути. Обычно массив, где для соответствующего элемента хранится его предок. 
Необязательно хранить две его координаты, например, можно определять направление откуда пришли в эту ячейку. 
Тогда намного проще код может получиться.   

## Наибольшая общая подпоследовательность
Даны две строки, найти максимально длинную подпоследовательность (т.е. не обязательно соседние буквы), 
которая есть в обеих строках  
![img.png](../images/lcs.png)  
Матрица dp. Окантуем ее нулями слева и сверху, как обычно - так удобнее.   
В ячейке (i, j) храним максимальную длину подпоследовательности, которую можно составить из i букв одной строки 
и j другой. Тогда (см. на рис. y и z):  
```python
dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```
Кроме случая, когда буквы, соответствующие i и j совпадают. В этом случае можем заменить (см. на рис. x):  
```python
if s[i - 1] == t[j - 1]: # не забываем, что добавили окантовку в dp  
    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)
```
Ответ в правой нижней ячейке  
Восстановление ответа. Еще один массив. Сохраняем в нем с какого направления пришли в данную ячейку: x, y или z. 
Потом будем идти из правого нижнего угла и если пришли из x (dp[i][j] == dp[i - 1][j - 1] + 1), 
то включаем текущую ячейку в ответ, если y или z (dp[i][j] == dp[i - 1][j]), то переходим туда (i--), 
но не добавляем ячейку в ответ.  


## Наибольшая возрастающая последовательность
Дана последовательность arr: 3 1 2 4 6 5 3  

### Решение N^2
Массив dp длиной N+1. dp[i] - длина НВП для первых i чисел. dp[0] = 0.  
dp[i] = max(1, 1 + max(среди dp[k] для которых arr[k] < arr[i])). Поиск max будет за N.  
Ответ - max(dp).  
Восстановление ответа: в массиве родителей для каждого i хранить, где был этот максимум - там и есть предыдущее число. 

### Решение NlogN
Массив dp длиной N+1. dp[i] - минимальное число, на которое заканчивается возрастающая подпоследовательность длины i. 
dp[0] = -бесконечность, остальные - +бесконечность.  
dp пошагово:  
| - + + + + + + +  
| - 3 + + + + + +  
| - 1 + + + + + +  
| - 1 2 + + + + +  
| - 1 2 4 + + + +  
| - 1 2 4 6 + + +  
| - 1 2 4 5 + + +  
| - 1 2 3 5 + + +  
Эдакий "стек", в который мы погружаем маленькие числа.
Начинаем обрабатывать с первого числа. Каждый раз корректируем нужные элементы в dp, находя их бинарным поиском
```c++
for (int x : arr) {
    int pos = lower_band(dp.begin(), dp.end(), x);
    dp[pos] = x;
}
```
Ответом максимальный индекс в dp такой, что значение в нем не +бесконечность.  
Для восстановления ответа можно поддерживать заполнение двух массивов: pos и prev. 
В pos[i] будем хранить индекс элемента, на который заканчивается оптимальная подпоследовательность длины i, 
а в prev[i] - позицию предыдущего элемента для arr[i]. 
Когда в стек погружаем число его индекс записываем в соответствующую позицию pos: pos[j] = i. 
Предыдущим для этого числа является число находящееся в pos левее, его и записываем в prev: prev[i] = pos[j - 1].  
```pseudocode
for i = 0 to n - 1
    j = binary_search(dp, arr[i])
    if (dp[j - 1] < arr[i] and arr[i] < dp[j])
        dp[j] = arr[i]
        pos[j] = i
        prev[i] = pos[j - 1]
        length = max(length, j)
```  
Начинаем с элемента в pos, соответствующего длине нвп. Далее перескакиваем по элементам в prev.    
```pseudocode
p = pos[length]
while p != -1
    answer.push_back(arr[p])
    p = prev[p]
reverse(answer)
```


## Расстояние между строками
Минимальное количество действий, чтобы превратить одну строку в другую (t в s, например). Возможные действия:
- удалить букву;
- вставить букву;
- заменить букву.

![img.png](../images/ssd.png)  
dp[i][j] - расстояние для префиксов длиной i и j. T + 1 на S + 1, т.к. делаем окантовку. dp[0][0] = 0. 
Ответ в dp[T][S]. Если буквы i и j совпадают, то слова удлинятся на 1, но расстояние между ними не изменится. 
А если не совпадают, то есть 3 варианта действий:  
```псевдокод
if s[i -1] == t[i - 1])  // не забываем, что у нас окантовка
    dp[i][j] = dp[i - 1][j - 1]  // слова удлинились на 1, но расстояние не изменилось
else
    dp[i][j] = min(
            dp[i - 1][j - 1] + 1,  // x, заменить одну букву на другую
            dp[i][j - 1] + 1,  // y, добавить одну букву
            dp[i - 1][j] + 1  // z, убрать одну букву
    )    
}
```

## Определите количество N-значных плавных чисел
Плавное, если значения соседних цифр отличаются не более, чем на 1. 
Запись числа не может начинаться с цифры 0.  
Представляем число в виде массива цифр.  
dp[i, j] - количество чисел длиной i, заканчивающихся цифрой j.  
```псевдокод
инициируем: dp(1, 0) = 0; dp(1, 1...9) = 1
для j = 1..8: dp(i, j) = dp(i-1, j-1) + dp(i-1, j) + dp(i-1, j+1)
dp(i, 0) = dp(i-1, 0) + dp(i-1, 1)
dp(i, 9) = dp(i-1, 9) + dp(i-1, 8)
```


## Рюкзак

Для случая, когда веса предметов - это действительные числа, быстрые полиномиальные решения с динамикой не работают, 
и надо писать перебор.
Похож на задачи, связанные с расписанием?

### Полный рюкзак
Можно ли из заданных грузов собрать рюкзак вместимости X?  
![img.png](../images/backpack.png)  
w - веса предметов.  
Булевский массив dp. (N + 1) * (W + 1), где N - количество предметов, W - общий вес предметов (наверное, достаточно X?).
Добавляем значения 0. Изначально все - False. dp[0][0] = True - 0 предметов могут дать 0 кг.  
Берем (или не берем) предметы начиная с первого. dp[i][j]. Рюкзак размером j можно заполнить полностью взяв несколько 
из i первых предметов, если мы уже получали вес j даже для i - 1 предмета или получали для i - 1 предмета вес меньше 
ровно на вес i-го предмета. O(X*n).  
```python
for i in range(1, n + 1):
    for j in range(0, W + 1):
        dp[i][j] = dp[i - 1][j]
        if w[i] <= j and dp[i - 1][j - w[i]]:  # первое - чтобы не вылезти за пределы массива?
            dp[i][j] = True
```  
Ответ в dp[N + 1][X] True.  

Модификация. Нам нужна информация только с предыдущей строки матрицы dp, левее текущей ячейки. 
Можно использовать массив длины W + 1, но, чтобы не перезатирались нужные в будущем данные, будем бежать по нему 
справа налево. Бежать дальше, чем вес текущего предмета не нужно: там значения и останутся такие же, 
как в предыдущей строке.  
```c
for (int x : arr) {
    for (int j = W + 1; j >= x; j--) {
        dp[j] = dp[j - x] || dp[j]
    }
}
```

Рюкзак на битсете. Можем не массив булевых значений хранить (по байту на значение?), 
а использовать bitset - по биту на значение. Битсет поддерживает побитовые операции, в т.ч. смещение. 
dp = dp | (dp << w[i])


### Рюкзак со стоимостями
Надо выбрать из n предметов рюкзак с наибольшей суммарной стоимостью, но весом не превосходящим W.  
w - веса предметов, c - их стоимости. В dp[i][j] максимальная суммарная стоимость набора из первых i предметов 
для рюкзака размера j. Изначально весь dp заполнен нулями.  
Ответ - максимальный dp[n][j].  
O(W*n). Тоже возможна модификация с dp размером 1 х (W + 1), с движением справа-налево.  
```python
for i in range(1, n + 1):
    for j in range(0, W + 1):
        dp[i][j] = dp[i - 1][j]
        if w[i] <= j:
            dp[i][j] = max(dp[i][j], dp[i - 1][j - w[i]] + c[i])
```  

Восстановление ответа. Движемся от ячейки с ответом: max(dp[n][j]). Если значение над нами такое же, 
значит эту вещь мы не брали, иначе берем вещь в ответ и смещаемся влево (уменьшаем вес рюкзака = достаем вещь) на w[i].  


### Рюкзак meet in the middle
Задача про полный рюкзак. Огромный рюкзак - 10^18, небольшое количество вещей (N <= 40).  
Решение не динамическое. Делим рюкзак на 2 половины. На одну накладываем все возможные маски - берем/не берем в набор 
и запихиваем в set, unordered_set или массив (который потом отсортируем и бинпоиском работать будем?). 
Теперь те же маски на вторую половину и проверяем каждый получающийся вес на наличие пары в первом контейнере: 
есть ли в нем вес, равный (X - вес справа).  


### Рюкзак с малыми ценами и огромными массами
В динамике можно выбирать, каким "измерением" мы будем описывать систему.  
N < 500, wi < 10^9, ci < 10^5, X < 10^9.
Нельзя создать массив такого размера X. Делаем массив длиной в максимальную стоимость всех вещей, 
заполняем бесконечностями. 
А внутри него храним минимальные массы, которыми можно соответствующую стоимость s набрать среди первых i элементов.  
dp[i] = MIN(dp[s][i - 1], dp[s - c[i]][i - 1] + w[i])  
Ответ - максимальное i, которое не равно бесконечности.

