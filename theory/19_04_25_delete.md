## Двоичное дерево поиска
https://ru.algorithmica.org/cs/tree-structures/  
https://neerc.ifmo.ru/wiki/index.php?title=Дерево_поиска,_наивная_реализация   
Бинарное дерево поиска (англ. binary search tree, BST).  
Сами по себе в олимпиадах используются редко?  
У каждой вершины не более двух детей. Все вершины обладают ключами, на которых определена операция сравнения 
(например, целые числа или строки). У всех вершин левого поддерева вершины v ключи не больше, чем ключ v. 
У всех вершин правого поддерева вершины v ключи больше, чем ключ v. 
Оба поддерева — левое и правое — являются двоичными деревьями поиска. 
Можно по-разному построить на одном и том же множестве элементов.  
Более общим понятием являются обычные (не бинарные) деревья поиска — в них количество детей может быть больше двух, 
и при этом в «более левых» поддеревьях ключи должны быть меньше, чем «более правых».  
Основное преимущество бинарных деревьев поиска в том, что в них можно легко производить поиск элементов. 
Основные функции (поиск, вставка, удаление) работают в худшем случае (бамбук) за O(n). 
Поэтому в эффективных реализациях поддерживаются некоторые инварианты, гарантирующую среднюю глубину вершины O(logn). 
Такие деревья называются сбалансированными.  
Деревья чаще всего представляются в памяти как динамически создаваемые структуры с явными указателями на своих детей, 
либо как элементы массива связанные отношениями, неявно определёнными их позициями в массиве. 
Чаще всего бинарные деревья поиска хранят в виде структур — по одной на каждую вершину — в которых записаны ссылки 
(возможно, пустые) на правого и левого сына, ключ и, возможно, какие-то дополнительные данные. 
struct Node {int x; Node *l, *r;};  

### Декартово дерево
https://algorithmica.org/ru/treap  
http://www.e-maxx-ru.1gb.ru/algo/treap  
https://neerc.ifmo.ru/wiki/index.php?title=Декартово_дерево  
Предложены в 1996г (1989?).  
Декартово дерево объединяет в себе бинарное дерево поиска и бинарную кучу. И похожа на пирамиду. 
Отсюда куча названий: ДеРамида, КуРево, ПиВо, TreAp. 
ДД является двоичным деревом поиска по x и пирамидой по y.  
Строится так. На плоскости точки.x - ключ, y - приоритет. 
Берем самую верхнюю точку (любую, если их несколько) в качестве корня.
Для всех вершин с меньшим x, чем у корня, рекурсивно запускаем процесс. 
Корень левой части присоединяем к общему корню. 
То же делаем для правой части.  
Если все x и y различны, то дерево строится однозначно. 
В худшем варианте получится бамбук. Поэтому это рандомизированное дерево поиска.  
Как и двоичное дерево поиска позволяет отвечать на запросы: добавить число во множество, есть ли число во множестве, 
lower_bound, количество чисел в промежутке \[l, r]. За O(log n).  
Декартово дерево удобно писать на указателях и структурах.


## Корневая эвристика
Корневые эвристики (Sqrt-декомпозиция) — это обобщённое название различных методов и структур данных, 
опирающихся на тот факт, что если мы разделим какое-то множество из n элементов на блоки по sqrt(n) элементов, 
то самих этих блоков будет не более sqrt(n).  
https://neerc.ifmo.ru/wiki/index.php?title=Статистики_на_отрезках._Корневая_эвристика  
https://algorithmica.org/ru/sqrt  
http://www.e-maxx-ru.1gb.ru/algo/sqrt_decomposition  

### Корневая декомпозиция на массивах
Задача нахождения суммы/макс/мин на отрезке [l...r] массива A.  
Предподсчет - построение массива B ( O(n) ):
- Разделим массив на ~sqrt(n) блоков длины ~sqrt(n). 
- В каждом блоке заранее посчитаем необходимую операцию. 
- Запишем результаты в массив длиной ~sqrt(n).  

Запрос на выполнение операции на отрезке [l,r]. Могут быть 2 крайних блока, входящих частично 
и несколько центральных, входящих полностью. Крайние считаем тривиально, значения для центральных  смотрим в масиве B. 
O(sqrt(n)).  
Запрос на изменение элемента. Реализация данного запроса будет зависеть от того, имеет ли операция, 
для которой сделано построение, обратную операцию и обладает ли она свойством коммутативности:
- если оба условия выполняются, то запрос на изменение элемента можно сделать за O(1)
  (меняем сам элемент и его родителя в массиве B);
- если хотя бы одно из условий не выполняется, то запрос на изменение элемента можно сделать за O(sqrt(n)).

Если изменяется не один элемент, а элементы на каком-то отрезке, то можно, видимо, устроить lazy propagation: 
если ко всем элементам блока надо прибавить какое-то число, то сохраняем его в отдельном массиве 
C (длиной тоже ~sqrt(n)). 
Числа из блокового массива C используем при ответах на запросы на выполнение операции.

### Корневая эвристика на запросах
Нам даются некоторые входные данные, а затем поступают q запросов на изменение или подсчет. 
Разобьём входные запросы на блоки длиной sqrt(q). 
В начале обработки каждого блока будем строить структуру данных для "оффлайнового" варианта задачи 
по состоянию данных на момент начала этого блока (для суммы на отрезке - массив префиксных сумм).  
Если первые запросы на ответ - даем их. Если потом приходят запросы на изменение - пропускаем их. 
А когда придет запрос на ответ, посчитаем ответ на исходном массиве, 
а потом пробежимся по всем пропущенным запросам на изменение и применим те из них, 
что затрагивают используемые для данного ответа ячейки.  
После блока запросов sqrt(n) перестраиваем массив с учетом поступивших запросов на изменение
(через разностный массив, конечно).  
O(n∙sqrt(n) + q∙sqrt(n)).  

### СНМ с удалением ребер
Обычная для СНМ задача, но кроме добавления ребер есть и их удаление.  
Строим граф на начало текущего блока сразу же не включая в него те ребра, 
которые в течение этого блока будут удаляться. Строим СНМ.  
Дальше не понял. На каждый запрос добавления надо к исходному СНМ добавлять ребро? 
На каждый запрос ответа добавлять все ребра удаляемые правее? Как это делать? На копии СНМ?  


# Геометрия
https://ru.algorithmica.org/cs/geometry-basic/

## Векторы
Сумма векторов: (ax, ay) + (bx, by) = (ax + bx, ay + by)  
Скалярное произведение: (ax, ay) * (bx, by) = ax·bx + ay·by = |a| * |b| * cosA  
Модуль векторного произведения — площадь параллелограмма (удвоенная площадь треугольника), считаем через матрицу:  
|(ax, ay) х (bx, by)| = |ax ay| = ax·by - ay·bx = |a|·|b|·sinA  
                        |bx by|  

Вектор перпендикулярный вектору (x, y) — это вектор (-y, x). Используем скалярное произведение.    

Принадлежит ли точка D углу AOB? 2 способа:
1) AD не пересекает прямую OB + BD не пересекает прямую OA;
2) OAxOD и OAxOB имеют один знак.

Принадлежит ли точка треугольнику? 
Достаточно проверить принадлежность точки любым двум углам треугольника.  

tgA = |a x b| / a·b = |a|·|b|·sinA / (|a|·|b|·cosA) = sinA / cosA = tgA  
atan2(y, x) => atan2(модуль векторного произведения, скалярное произведение). 
Вернет результат (-pi; pi] в отличие от atan, возвращающего [-pi/2; pi/2].  


## Прямые и отрезки
Точками AB задана прямая, пересекает ли ее отрезок CD? 
Смотрим разный ли знак у произведений ABxAC и ABxAD.  

Пересекаются ли отрезки M1M2 и P1P2 = концы отрезка лежат по разные стороны относительно другого отрезка. 
Считаем и для того, и для другого отрезка. Например, лежат ли M1 и M2 по разные стороны от P1P2 = 
разные ли знаки у векторных произведений:  
[(M1 − P1) × (P2 − P1 )] ⋅ [(M2 − P1) × (P2 − P1)] < 0

Прямые можно задавать разным образом: двумя точками, Ax + By + C = 0, точка и направляющий вектор, точка и нормаль.  
В зависимости от задачи удобнее тот или иной — надо уметь [переходить](
https://ru.algorithmica.org/cs/geometry-basic/segments/) из одного в другой. 

Уравнение прямой на плоскости: ax + by + c = 0.  
Неравенства ax + by + c > (или <) 0 описывают полуплоскости - можем определять в какой полуплоскости точка.  
Вектор (a, b) - перпендикуляр к прямой (в сторону положительной полуплоскости).  

Принадлежит ли точка C прямой AB? 2 варианта:
1) AB x AC == 0;
2) Через уравнение прямой:
    - находим перпендикуляр к вектору AB, получая a и b для уравнения прямой на плоскости;
    - находим c из уравнения прямой, подставив точку A, например;
    - проверяем, что точка C подходит к получившемуся уравнению прямой.

Заданы 2 прямые:  
Ax + By + C = 0  
Dx + Ey + F = 0  
Найти точку пересечения.  
Просто выражаем игрики, приравниваем, получаем выражение для икса. 
Точно так же для игрека.  
Если A, B, D, E не нулевые (?), то решение есть всегда, кроме случаев когда прямые параллельны. 
Эти случаи (параллельность и совпадение) нужно обрабатывать отдельно. 
В знаменателе выражений будет, фактически, стоять векторное произведение.  

Расстояние от точки (x0, y0) до прямой: d = |A ∙ x0 + B ∙ y0 + C| / sqrt(A^2 + B^2). 
Об этой формуле можно думать как о скалярном произведении вектора-точки на нормированный (1 / sqrt(A^2 + B^2)) 
вектор нормали, геометрически равный проекции точки на него.  
Если же прямая задана 2 точками, то можно выразить высоту из формулы для площади треугольника.  

## Расстояние

Расстояние от точки (x0, y0) до прямой: |Ax0 + By0 + C| / sqrt(A^2 + B^2). 
Как-то выводится из того, что (A, B) - перпендикуляр к прямой?  

Расстояние от точки A до луча, начинающегося в B. Если точка "над" лучом, то задача сводится к предыдущей. 
Если нет, то это расстояние между двумя точками. 
Первое или второе мы узнаем по знаку скалярного произведения вектора луча и вектора BA.    

Расстояние от точки A до отрезка BC. 
Можно, например, свести к предыдущей. Дважды находим ответ: для луча BC и CB. И выбираем максимум. 
Наверное, можно скалярными произведениями понять, что точка не "над" отрезком и заифать?   

Расстояния от отрезка AB до отрезка CD: 
1) проверка — пересекаются ли. Для всех четырех точек посмотреть, что точки другого отрезка находятся по разные стороны? 
Например, для точки A, что AC x AB и AB x AD не имеют одного знака (0 - подходит - касаются кончиком);  
2) Далее измерять расстояние от всех четырех точек до другого отрезка.


## Многоугольники
Простой - нет точек самопересчечения.

### Площадь
Площадь треугольника ABC через векторное произведение двух векторов: V= (B − A) × (C − A) / 2.  
Многоугольник без самопересечений задан последовательностью вершин в порядке обхода, можно поступить так. 
Пройдемся по всем ребрам и для каждого добавим в общую сумму площадь (со знаком) треугольника, 
заданного этим ребром и началом координат. Вернем сумму по модулю.  
Также существует возможно более интуитивный, но и более громоздкий метод трапеций.  

### Принадлежность точки многоугольнику
Находится ли точка P в треугольнике ABC, заданном против часовой стрелки. 
Тогда она должна лежать слева от всех трёх отрезков AB, BC и CA. 
Система трех неравенств:  
(B−A) × (P−A) ≥ 0  
(C−B) × (P−B) ≥ 0  
(A−C) × (P−C) ≥ 0  
Для выпуклых многоугольников так же. 
Проверка выпуклости многоугольника: для всех последовательных точек a, b, c проверить, что (b − a) × (c − a) > 0.

#### Произвольный многоугольник
Вариант 1. Пройдемся по всем вершинам в порядке обхода и будем последовательно рассматривать углы 
с вершиной в точке P и лучами, проходящими через соседние вершины многоугольника. 
Если просуммировать эти ориентированные углы, то получится какая-то величина θ. 
Если точка P лежит внутри многоугольника, то θ = ±2π, иначе θ = 0.  
Вариант 2. Считаем сколько раз луч, выпущенный из P, пересекает ребра многоугольника. 
Для точки, находящейся внутри, это число будет нечетным, в противном случае — четным (в т.ч. 0?). 
Чтобы не обрабатывать отдельно случаи, когда луч пересекает вершину бросим луч случайным образом, 
надеясь, что так не повезти, нам не может.

## Перегрузка операторов
Удобно не формулы таскать везде, а написать функцию или перегрузить операторы: 
int operator^(r a, r b) { return a.x*b.y - b.x*a.y; }  
Для точек и отрезков удобно создавать свои struct.  