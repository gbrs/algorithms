# Графы

Обычно, задачи на графы формально вообще не про графы: надо еще догадаться, что здесь узлы, а что ребра
(состояния и переходы между этими состояниями). 
Например, двумерные карты с водой и островами, комнаты со стенами (лабиринты). 
Головоломка о переливании воды с двумя сосудами (массив состояний - сколько литров в каждом ведре, 
надо аккуратно описать все возможные ходы: дополнить/опустошить/перелить; перебираем состояния пока не дойдем до 
подходящего - сколько-то литров в одном из ведер).  
Массив предков для хранения на i-й позиции родителя i-й вершины.  

| Задача                                | BFS | DFS |
|:--------------------------------------|:---:|:---:|
| Поиск кратчайшего пути от a до b      |  v  |  x  |
| Проверка существования пути от a до b |  v  |  v  |
| Поиск компонент связности             |  v  |  v  |
| Поиск циклов                          |  x  |  v  |
| Проверка на двудольность              |  v  |  v  |
| Топологическая сортировка             |  x  |  v  |
| Поиск компонент сильной связности     |  x  |  v  |

Поиск циклов бфсом возможен только специфичный: для данной вершины. 
Запускаемся от нее и смотрим не появится ли в потомках эта вершина. 
Для произвольной вершины придется бфс запустить от каждой. 
Зато найдет именно минимальный цикл.  
У BFSа нет риска переполнения стека рекурсии. 

## DFS
рекурсивный DFS. Прямой обход: NLR. Бежим до левого нижнего листа, потом шаг назад и пытаемся сделать шаг правее. 
И т.д. Для шагов каждый раз вызываем рекурсивно алгоритм. Используем список смежности, ведем список уже посещенных 
вершин (это просто массив: обычно в задачах вершины задаются порядковыми номерами, и значит мы можем хранить информацию 
по соответствующему индексу массива).  
Рекурсивный вариант - классика. Простой вариант со стеком (как bfs, но вместо очереди - стек) обходит вершины 
несколько в ином порядке, что не позволяет решать некоторые задачи. 
Но можно сделать более сложный вариант, обходящий так же как и рекурсивный.  
Работает и с ориентированными, и с не ориентированными графами. Сложность O(V + E).

### Достижима ли вершина f из вершины s? 
Делаем dfs из s и смотрим отмечена ли вершина f в списке посещенных вершин.  

### Cколько вершин можно достичь из заданной вершины? 
В массиве посещенных вершин будут отмечены только достижимые вершины.  

### Поиск/раскраска/подсчет компонент связности
https://www.youtube.com/watch?v=rZkauRhHKGo   
Бежим циклом по вершинам в списке посещенных вершин и запускаем дфс от каждой еще не посещенной вершинки. 
В еще одном массиве отмечаем к какой из компонент связности относится данная вершина (для подсчета кс достаточно 
счетчика, конечно). 
Впрочем, эту информацию можно хранить и в списке посещенных вершин: 0, если не посетили, и номер кс в ином случае.  

### Поиск циклов в ориентированном графе
https://www.youtube.com/watch?v=pB83tSvoBuc  
Сначала все вершины белые (нолики в списке посещенных вершин). 
При первом посещении вершины (в начале функции дфс) красим вершину в серый - 1, 
при последнем (в конце функции дфс) - в черный (2). 
Цикл - это когда мы встречаем серую вершину (мы вошли в нее, но еще не вышли).  
Для _восстановления цикла_ создаем массив для хранения на i-й позиции родителя i-й вершины. 
Как только находим цикл брэкаем всю рекурсию (а то там же происходят перезаписывания родителей). 
Остается пробежаться по массиву родителей от вершины, замкнувшей цикл до нее же. Получившийся массив реверснуть.  

### Поиск циклов в неориентированном графе
https://www.youtube.com/watch?v=8QFS6AC0WeI  
Все так же как с ориентированным графом, только надо объяснить программе, что цикл 1-2-1 нас не устраивает.
(Разве? А не надо выкинуть окраску в черный цвет? Хотя это и не помешает, но оно не нужно). 
Поэтому передаем в функцию дфс номер родителя и не учитываем этот узел при решении вопроса о наличии цикла. 

### Двудольность графа
https://www.youtube.com/watch?v=8QFS6AC0WeI  
Решается "жадно". 
Идем дфсом и красим вершины попеременно в 1 и 2. 
Если встречаем посещенную вершину, то проверяем, окрашена ли она в противоположный цвет = 3 - цвет текущей вершины. 

### Топологическая сортировка
https://www.youtube.com/watch?v=o0P8oNXoA_w  
DAG - ориентированный ацикличный(!) граф.  
DFS делаем и на выходе из узла (лист или обошли всех детей уже) добавляем узел в массив. Потом, перевернув этот массив, 
получаем "отсортированный" список узлов: для любой вершины из него знаем, что путь в нее шел только через вершины, 
расположенные левее нее. Все ребра в этом списке идут строго слева направо. Топологическая сортировка не единственна, 
это не помешает.  
Бывают задачи, в которых надо считать не с начала списка топсорта, а с конца.  
Задача _нахождения кратчайшего пути_ во взвешенном графе решается тогда всего за O(V + E). 
Но не забываем ограничение - только в ацикличном графе. 
Создаем "обратный" список смежности (осс): откуда в эту вершину можем прийти. 
Внешний цикл - по вершинам топологически отсортированного, внутренний - по предкам выбранной во внешнем цикле вершины 
(используем осс). 
Пробуем прорелаксировать ребро dist[i] = min(dist[i], dist[j] + длина i-j), как в Форде-Беллмане. 
В Форде-Беллмане мы наугад тыкали все пути, а здесь, благодаря осс и топсорту, мы только то, что надо перебираем.  
Задача на нахождение _количества путей_ до какой-то вершинки. Тот же алгоритм. cnt[i] = сумма всех cnt[j] (количеств 
путей до родителей).  
_Нахождение компонент сильной связности_ (ксс) в ориентированном графе с циклами. 
https://www.youtube.com/watch?v=-UgiBh1IMQU  
Внутри ксс можно в конце концов попасть из каждого узла в каждый. 
Узлов в ксс может быть 1, 3 и более.  
Создаем граф, в котором все ребра направлены в противоположном направлении. 
Делаем топсорт по этому графу (конечно, неправильно так говорить, когда граф с циклами; правильно: сортировка 
по убыванию времени выхода при dfs).
Запускаем dfs на исходном графе, но в порядке топсорта, полученного на вспомогательном графе.
Находим всю ксс для первого узла, отмечаем эти вершины, как принадлежащие первой ксс, отмечаем уже посещенные вершины.  
Теперь строим ксс для следующей в топсорте вершины, которую мы еще не посетили.

### "Карта"
https://www.youtube.com/watch?v=waXBVBKdV1s  
Двумерная карта, где 0 - вода, 1 - суша. Или комната со стенками (лабиринт).   
Можно, конечно, создать явный граф на этой основе. Но так не делают.  
Массив посещенных вершин будет матрицей такого же размера. 
Можно вместо него использовать исходную карту. 
Надо будет обходить 4/8 соседей клетки (i, j) и лучше заранее создать список кортежей[(0, 1), (0, -1), (-1, 0), (1, 0)]. 
В C++ это будут 2 массива смещений: [0, 0, -1, 1] и [1, -1, 0, 0]. 
Внутри функции дфс отмечаем клетку посещенной и бежим по созданным кортежам и прибавляем значения из них 
к координатам текущей клетки. 
Если получившаяся соседняя клетка не выходит за границы, не посещена и является сушей, то запускаем от нее рекурсивно 
дфс.  
Если надо все _острова "раскрасить"_, то снаружи цикл по списку посещенных клеток. Если клетка не посещалась 
и является сушей, то запускаем от нее дфс. Первый остров в матрице посещенных клеток "красим" единичками, 
второй - двойками и т.д.   
Если надо только _посчитать количество островов_, то можно обойтись счетчиком.

---

## BFS
https://ru.algorithmica.org/cs/shortest-paths/bfs/
https://www.youtube.com/watch?v=4iDv8Zu8L3I  
Использование очереди - классика. 
Но, как я понял, это потому, что в других задачах на основе BFS очередь нужна. 
Сам обход можно было бы совершать просто итерируясь whileом по списку, в конец которого мы добавляем "новые" вершины.  
Создадим массив расстояний. Напротив индекса стартовой вершины - 0. В остальных сначала - плюс бесконечности. 
Кладем в очередь стартовую вершину.  
Пока очередь не пуста, извлекаем из очереди левую вершину. 
Определяем ее непосещенных соседей (у них дистанция - бесконечность; но для некоторых задач лучше условие записать: 
текущее расстояние > расстояние до родителя + 1). 
Отмечаем соседку посещенной и записываем кратчайший путь до нее: +1 к расстоянию у родительницы.  
У вершин других компонент связности расстояние останется - бесконечность.  
Работает и с ориентированными и неориентированными графами. Сложность O(V + E).

### Восстановление кратчайшего пути
Как всегда: массив предков. При каждом обновлении массива расстояний обновляем и массив предков.

### Множественный BFS
Добавив в очередь изначально не одну, а несколько вершин, 
мы найдем для каждой вершины кратчайшее расстояние до одной из них. 
Это полезно для задач, в которых нужно моделировать пожар, наводнение и т.п., в которых источник «волны» не один.  
Также так можно чуть быстрее находить кратчайший путь для конкретной пары вершин, 
запустив параллельно два обхода от каждой и остановив в тот момент, когда они встретятся.

### Все вершины, лежащие на кратчайших путях из A в B
Запускаем бфс из A. Пусть расстояние 4. Запускаем бфс из B. Получаем два массива расстояний.
(Такой трюк с двойным запуском можно провернуть с любым алгоритмом, находящим кратчайший путь.) 
На кратчайших путях лежат все вершины, для которых сумма расстояний в этих массивах равна 4. 
Ребро лежит на кратчайшем пути, если сумма расстояний от одной вершины до A и от другой до B равна 3.

### Кратчайшие циклы
Найти кратчайший цикл в ориентированном невзвешенном графе.  
Произвести поиск в ширину из каждой вершины. 
Как только в процессе обхода мы натыкаемся на уже посещённую вершину - 
нашли кратчайший цикл для данной вершины, и останавливаем обход. 
Среди всех таких найденных циклов выбираем кратчайший.

### 1-k BFS
Задача нахождения кратчайших путей от вершины s для случая, когда расстояния от 1 до некоего небольшого k
(и небольшого числа вершин?). Или есть заметное ограничение на максимальную длину кратчайшего пути.  
Решение за O(kV + E)!  
В массиве dist храним расстояния от стартовой вершины. 
Заполняем его бесконечностями, для стартовой вершины - 0.  
Создаем массив mq размера k * (n - 1) + 1 (под максимально возможное расстояние + нулевое) и заполняем его очередями.
(Не понял зачем очередь нужна, а не просто массив). 
Будем в i-ой очереди хранить вершины, которые имеют какой-нибудь путь длиной i от стартовой.  
Кладем в очередь на i = 0 стартовую вершину.  
Бежим по массиву очередей.  
____Если очередь не пуста, попаем по порядку вершинки v.  
________Теперь, пользуясь списком смежности, обрабатываем всех ее соседей u: 1) добавляем их в соответствующие очереди: 
dist[v] + расстояние до соседа и 2) пробуем релаксировать расстояние до соседа в dist[u].  
Заметим, что в тот момент, когда мы в первый раз в очередях mq встречаем вершину, 
в dist уже лежит кратчайшее расстояние до нее (не может быть пути короче, 
который проходил бы через вершины расположенные правее, а вершины левее мы уже все обработали).  
Чтобы не перелопачивать соседей уже обработанных вершинок заново, попнув вершину, сверяемся с used.  
Улучшение по памяти. Обработанные очереди нас уже не интересуют, 
а заполненные очереди, которые надо будет обработать в дальнейшем, находятся не далее чем на k, от текущей очереди. 
Значит нам достаточно массива очередей размером k+1. 
Куда именно класть соседей, каждый раз будем определять делением по модулю на k + 1.  
Один рассказывал так, что пути не обязательно целые. По ячейкам распределяем в соответствии с округлением вниз. 
Расстояние минимум 1 гарантирует, что соседи окажутся в другой ячейке.  


dist[s] = 0;

queue<int> q[maxdist];  // вектор очередей
q[0].push_back(s);

for (int i = 0; i < maxdist; i++) {
    while (!q[i].empty()) {
        int v = q[i].front();
        q[i].pop();
        // если расстояние меньше и мы уже рассмотрели эту вершину,
        // но она всё ещё лежит в более верхней очереди
        if (dist[v] < i)  // в исходнике знак был >
            continue;
        for (auto [neighbour, weight] : g[v]) {
            if (dist[neighbour] > dist[v] + weight) {  // в исходнике знак был <
                dist[neighbour] = dist[v] + weight;
                q[dist[neighbour]].push(u);
            }
        }
    }
}

void bfs(int start_vertex, vector<int> &dist, vector<vector<pair<int, int>>> &graph, int max_w)
{
    fill(dist.begin(), dist.end(), INT_MAX);
    vector<bool> used(dist.size(), false);
    vector<deque<int>> q(max_w + 1);
    int current_q = 0, cnt_in_queue = 1;
    dist[start_vertex] = 0;
    q[current_q].push_back(start_vertex);
    while (0 < cnt_in_queue) {
        //пропускаем пустые очереди
        while (q[current_q % (max_w + 1)].empty()) {
            current_q++;
        }
        //пропускаем пустые очереди
        int v = q[current_q][0];
        q[current_q].pop_front();
        cnt_in_queue--;
        if (used[v]) {
            continue;
        } else {
            used[v] = true;
            for (auto e : graph[v]) {
                if (dist[e.first] > dist[v] + e.second) {
                    dist[e.first] = dist[v] + e.second;
                    q[dist[e.first] % (max_w + 1)].push_back(e.first);
                    cnt_in_queue++;
                }
            }
        }
    }
}

### Алгоритм Дейкстры
https://www.youtube.com/watch?v=fA_xvuqzuGs https://www.youtube.com/watch?v=J-7MzbEtTR0  
Граф без отрицательных ребер. Найти минимальные расстояния до всех вершин из исходной.  
Инициализируем массив расстояний бесконечностями. Расстояние от самой вершины до неё же - 0. 
Все вершины графа помечаются как необработанные.  
Шаг алгоритма:  
- Если все вершины обработаны, алгоритм завершается.
- В противном случае из ещё необработанных вершин выбирается вершина u, имеющая минимальное расстояние 
(на первом шаге это стартовая вершина). Для этого в C++ удобно использовать вместо очереди set из пар 
(расстояние, номер вершины). Не забывать обновлять расстояния и в этом множестве, а не только в массиве расстояний.
- Мы рассматриваем всех соседей вершины u. Для каждого соседа вершины u, кроме отмеченных как обработанные, 
рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом. 
Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. 
Рассмотрев всех соседей, пометим вершину u как обработанную и повторим шаг алгоритма.  

Используем очередь. Сложность обычного Дейкстры - O(V^2 + E), на множестве - O((V + E) * logV). Лучше? Да. 
Но если граф плотный E ~ V^2, алгоритм на множестве становится хуже: V^2 vs V^2 * logV.  

Восстановление путей. Можно создать массив p, в ячейках которого будет храниться родитель - 
вершина, из которой произошла последняя релаксация. 
Обновлять его можно параллельно с массивом dp. 


### Алгоритм Прима
Построить минимальное остовное дерево взвешенного связного неориентированного графа.  
Вектор dist длиной V с расстояниями +бесконечность до остова. 
Вектор used длиной V с нулями. Добавляя вершину в остов отмечаем ее единичкой. 
Список смежности длиной E с парами {соседка, расстояние до нее}. 
Приоритетная очередь (С++шный set с парами {расстояние до остова, вершина}). Приоритетность по расстоянию до остова.  
Добавим в очередь стартовую вершину (0, 0). dist[0] = 0. 
Пока очередь не пуста попаем вершину с минимальным расстоянием до остова. 
Добавляем ее в остов и добавляем в очередь ее соседок (если ребро не ведет в вершину, уже находящуюся в остове). 
Одновременно пытаемся релаксировать минимальное расстояние этих вершин до остова. Если расстояние уменьшилось, 
то нужно обновить dist, попнуть из очереди предыдущую пару и пушнуть пару с обновленным расстоянием.  
По пути в зависимости от задания: выводим входящие в остов ребра, суммируем длину остова...  
Сложность в зависимости от реализации: O(VE), O(E^2), O(ElogV). При плотном графе (E ~ V^2) третье хуже второго.   

### Алгоритм Форда-Беллмана
https://www.youtube.com/watch?v=cE5n2IKf7W4  
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Найти минимальные расстояния до всех вершин 
от стартовой.  
Инициализируем массив расстояний бесконечностями. Расстояние от самой вершины до неё же - 0.  
Пробегаемся по всем ребрам. Если расстояние до начальной вершины бесконечность, ничего не делаем. Если нет, 
то обновляем расстояние, если путь по данному ребру оказывается короче того, который уже записан для конечной вершины. 
dist[b] = min(dist[b], dist[a] + weight).  
Так делаем V - 1 раз: крайний случай, когда все вершинки расположены в одну линейную цепочку. 
На каждом шаге i гарантировано находим кратчайшее расстояние до вершин ранга i.  
Очень простой алгоритм: цикл в цикле - до V - 1 и обход по всем ребрам.  
Сложность большая - O(V*E).  
В большинстве случаев V - 1 прогонов - слишком много, большАя/бОльшая часть - в пустую.  
Можно завести флаг, чтобы брекнуться, если на предыдущей итерации цикла не было произведено ни одного изменения.  
А можно на первом шаге обновить расстояние только для соседей стартовой вершины. А на последующих шагах пытаться 
обновлять только соседей вершин, которые были обновлены на предыдущем шаге. Очередь нам в помощь. Это называют SPFA /
 алгоритм Мура / алгоритм Ф-Б с очередью.

![Методы определения расстояний между всеми вершинами](images/all_distances_table.png)

### Алгоритм Флойда-Уоршелла
https://www.youtube.com/watch?v=kaA3_qNfpCA https://www.youtube.com/watch?v=8JQ565Rz7d8  
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Построить матрицу минимальных расстояний между 
всеми вершинами.  
Динамическое программирование.  
Строим матрицу смежности d-1[i, j]. Если путей между двумя вершинами несколько, записываем кратчайшее расстояние. 
На главной диагонали - нули. Если есть отрицательные петли, то на главную диагональ записываем их 
(или минус бесконечность?). 
Если пути нет, записываем бесконечность.  
Теперь будем сравнивать имеющиеся пути с путем из i в 0, а потом из 0 в j. Где нашли путь короче, там заменяем, 
получая матрицу d0[i, j]. Далее повторяем с промежуточной вершиной 1 - получаем кратчайший путь из тех, которые идут 
прямо из i в j или через вершины 0 и 1. И т.д.  
Получается простейший алгоритм с тремя вложенными циклами: во внешнем перебираем промежуточные вершины, 
во внутренних - i и j.  

### Алгоритм Джонсона
https://www.youtube.com/watch?v=8JQ565Rz7d8  
Граф с возможностью отрицательных ребер (без отрицательных циклов?). Построить матрицу минимальных расстояний между 
всеми вершинами.  
Какой-то кентаврик. Без подробностей здесь записал.  
Запускается алгоритм Форда-Беллмана из всех вершин графа одновременно. Изменяем вес ребер по результатам ФБ, 
они становятся неотрицательными, кратчайшие пути (но не их значения) не изменяются. Теперь можно запускать Дейкстру из 
всех вершин. Корректируем расстояния, используя результаты ФБ.

### Задачи с отрицательными циклами
https://www.youtube.com/watch?v=LVnPNWwd-yo https://www.youtube.com/watch?v=LnOOuNcRLIo  

- Определить, есть ли в графе отрицательный цикл + 
- Вывести какой-то из отрицательных циклов +
- Вывести все отрицательные циклы (в общем случае) -
- Пометить вершины, до которых нет кратчайшего пути +
- Найти кратчайшие/длиннейшие простые пути (не содержащие циклов; в общем случае) - (np-полная?)

До некоторых вершин перестают существовать кратчайшие пути (они бесконечно большие).  
Алгоритмы Форда-Беллмана и Флойда-Уоршелла надо модифицировать, борясь с отрицательными переполнениями.


---

### Алгоритм Крускала
Построить минимальное остовное дерево взвешенного связного неориентированного графа.  
Жадник. 
Отсортируем рёбра и будем пытаться добавлять их в остов в порядке возрастания весов.
Если ребро соединяет какие-то две вершины внутри одной компоненты связности, то проигнорируем его. 
При этом образуется много компонент связности, иногда мы их соединяем.  
Для этих двух задач используем систему непересекающихся множеств.  
Сложность O(ElogE) определяется сложностью сортировки ребер.
