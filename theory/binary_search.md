# Бинарный поиск

O(logN).  
Найти заданное число в отсортированном массиве.  
Нельзя вот просто так взять и написать бинарный поиск. Подводные камни всплывают.  
Указатели l и r на крайние элементы ставим. Вычисляем центр m = (l + r) / 2. Если под ним искомое число - возвращаем c. 
Если меньшее число, то смещаем l на m + 1, а если большее: r на m - 1. Если l стало больше r - нет искомого числа. 
Но так мы нашли "любое" искомое число. Но, обычно, надо найти либо крайнее левое из таких чисел, либо крайнее правое. 
И тут могут быть подводные камни.  

## Левый бинарный поиск
Возможны разные подходы.  
Правый бинпоиск пишется симметрично.  
Цикл ведем до while l + 1 > r (пока указатели не встанут рядом). 
Если под m искомое число перемещаем r на m (вдруг и левее тоже стоит искомое число). 
l тоже строго на m смещаем. 
После окончания цикла проверяем не стоит ли под одним из указателей искомое число.  
Второй способ. Инициализируем: l = -1, m = len(lst). 
Тогда искомое число всегда будет под r, если оно есть. r указывает на первый элемент равный или больший искомого 
(может указывать и за правую границу массива - проверять это).  

## Бинарный поиск по ответу
Какого минимального размера квадратную доску надо взять, чтобы разместить на ней N дипломов размера H*W?  
Задача решается таким способом, если:  
- ответ на задачу меняется монотонно: до X все варианты не подходят, а с X все варианты подходят, либо наоборот;
- можно эффективно проверять подходит какой-то X или нет (такая инвертированная исходная задача).

Границу l инициализируем размером, который заведомо не подходит, а r - размером, который заведомо подойдет 
(конкретные значения зависят от задачи). 
Обычно создают отдельную функцию, которая возвращает True/False в ответ на вопрос: подходит ли нам ответ X. 
Запускаем левый (в этом случае: мы же ищем минимальную доску) бинарный поиск. 

## Вещественный бинарный поиск
Решить уравнение с какой-то точностью. Функция монотонная.  
Делаем бинарный поиск по ответу. Сколько раз?  
while r - l > e. Есть неочевидные проблемы. 
Если e слишком маленькая (а l - большая? /юб/), то m может все время совпадать с l. 
Получится бесконечный цикл.  
Поэтому советуют использовать for. Например, double - 64 бита. 
И тогда достаточно 64(?) итераций, чтобы достичь максимальной точности. 
Запускаем с запасом, к примеру, 100 итераций. 
Выводим l или r: они максимум отличаются в последнем бите мантиссы.

### Тернарный поиск
Троичный поиск.  
Найти минимум функции. Функция имеет только один минимум, левая ветвь монотонно убывает, правая - монотонно возрастает. 
Впрочем, в некоторых задачах минимумом может быть плоское донышко. 
К сожалению, во многих оптимизационных задачах эти условия не выполняются. 
Тогда надо график делить на подходящие участки.  
Две точки ml и mr: первая - правее l на 1/3, правая - на 2/3. 
Если f(ml) > f(mr), l = ml: выбрасываем левую треть. Иначе m = mr. 
При ml == mr можно выбросить крайние трети, но обычно не заморачиваются и выбрасывают одну. 
При определении количества итераций в for помнить, что основание логарифма у нас уже не 2, а только 1,5.  
К сожалению, если вычисление функции сложное, то быстро накапливаются погрешности и не удается достичь 
заданной точности.
